\subsection{Tool design}
	When doing the initial tool design, we chose to use as much of the functionality from M3 as we could, because we noticed that a lot of the information that is needed for constructing class diagrams was available in one way or the other.
	Because of this, we get the following information from M3 alone:

	\begin{itemize}
		\item Class names
		\item Field list
		\item Method list
		\item Field and method visibility
		\item Parameter and return types
		\item Extends relation
		\item Implements relation
	\end{itemize}

	Our implemention follows the style of an iterative program, rather than a functional one using lots of set comprehensions.
	We did this for two reasons.
	The first one is that we feel that it makes our code much more readable to the novice eyes and it allows for easier documentation.
	The second reason is that all of our private functions help to build one big string representation of the model.
	If we would chose to use set comprehensions to communicate data between our functions, we would have to transform the resulting set or relation to a string at some later moment.

	Our approach keeps everything transparent and building up to the result, though it does mix functionality and representation of data.
	We feel that this drawback is justified here, as the functionality we've introduced is not much more than getting the data out of M3 and sometimes performing some simple transformations on it.
	
	After we had this basic class diagram without dependencies and associations working, we set on to implement the algorithm described in \cite{rev-eng}.
	Because of the notation of the given tips and tricks and the distance of the implementation of this algorithm from the visualization, the \texttt{FlowPropagation} module is written in a more functional style.


\subsection{Usage}
	Usage of the toolchain requires a working Rascal installation within Eclipse and the Java2OFG project in the build path.

	The Racal module \texttt{ClassDiagram} exposes the following method: \texttt{public str getDot(loc projectLocation);}, which returns the Graphviz notation for the UML class diagram based on the Eclipse project that the given location points to.
	Note that this has to be a location to an Eclipse project and can not be just any other location because Java2OFG requires this.

	For ease of use, we have included the module \texttt{ClassDiagramIO}, which exposes \texttt{public void writeClassDiagramToFile(loc projectLoc, loc fileLoc);}.
	Using this method, a file in Graphviz notation will be written to \texttt{fileLoc} that contains a UML class diagram for the Eclipse project in \texttt{projectLoc}.
	
	Because of this, the following Rascal code is enough to get started:
	
	\begin{lstlisting}
	import ClassDiagramIO;
	writeClassDiagramToFile(|project://eLib|, |file:///tmp/eLib.dot|);
	\end{lstlisting}
	
	Then, the file can be visualized with for instance \texttt{dot -Tpng -O /tmp/eLib.dot}.
